<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>AI Super Resolution Demo (CDN only)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
body {
  font-family: system-ui, sans-serif;
  background: #f5f5f5;
  padding: 20px;
}
.panel {
  background: #fff;
  padding: 16px;
  border-radius: 8px;
  max-width: 900px;
  margin: auto;
}
.images {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
}
img {
  max-width: 100%;
  border: 1px solid #ccc;
}
button {
  padding: 8px 14px;
}
.status {
  font-size: 13px;
  margin-top: 8px;
}
</style>
</head>

<body>
<div class="panel">
  <h2>AI スーパー解像度（CDNのみ / Pages対応）</h2>

  <input type="file" id="file" accept="image/*">
  <button id="download" disabled>ダウンロード</button>

  <div class="images">
    <div>
      <p>元画像</p>
      <img id="src">
    </div>
    <div>
      <p>AI処理後</p>
      <img id="dst">
    </div>
  </div>

  <div class="status" id="status">画像を選択してください</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

<script>
const fileInput = document.getElementById("file");
const srcImg = document.getElementById("src");
const dstImg = document.getElementById("dst");
const status = document.getElementById("status");
const downloadBtn = document.getElementById("download");

let outputUrl = null;

/*
  超軽量 Super Resolution モデル（約3MB）
  x2 / エッジ強調タイプ
*/
const MODEL_URL =
  "https://huggingface.co/onnx-community/super-resolution/resolve/main/sr_x2_small.onnx";

let sessionPromise = ort.InferenceSession.create(MODEL_URL, {
  executionProviders: ["wasm"]
});

fileInput.onchange = async () => {
  const file = fileInput.files[0];
  if (!file) return;

  srcImg.src = URL.createObjectURL(file);
  status.textContent = "AI推論中…（ローカル処理）";
  downloadBtn.disabled = true;

  const img = new Image();
  img.onload = async () => {
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const input = new Float32Array(canvas.width * canvas.height * 3);

    for (let i = 0; i < canvas.width * canvas.height; i++) {
      input[i * 3 + 0] = imageData.data[i * 4 + 0] / 255;
      input[i * 3 + 1] = imageData.data[i * 4 + 1] / 255;
      input[i * 3 + 2] = imageData.data[i * 4 + 2] / 255;
    }

    const tensor = new ort.Tensor("float32", input, [1, 3, canvas.height, canvas.width]);
    const session = await sessionPromise;
    const output = await session.run({ input: tensor });

    const out = output.output.data;
    const outCanvas = document.createElement("canvas");
    outCanvas.width = canvas.width * 2;
    outCanvas.height = canvas.height * 2;
    const outCtx = outCanvas.getContext("2d");
    const outImage = outCtx.createImageData(outCanvas.width, outCanvas.height);

    for (let i = 0; i < outCanvas.width * outCanvas.height; i++) {
      outImage.data[i * 4 + 0] = out[i * 3 + 0] * 255;
      outImage.data[i * 4 + 1] = out[i * 3 + 1] * 255;
      outImage.data[i * 4 + 2] = out[i * 3 + 2] * 255;
      outImage.data[i * 4 + 3] = 255;
    }

    outCtx.putImageData(outImage, 0, 0);
    outputUrl = outCanvas.toDataURL("image/png");
    dstImg.src = outputUrl;

    status.textContent = "完了（AI処理）";
    downloadBtn.disabled = false;
  };
  img.src = srcImg.src;
};

downloadBtn.onclick = () => {
  const a = document.createElement("a");
  a.href = outputUrl;
  a.download = "ai_upscaled.png";
  a.click();
};
</script>
</body>
</html>
